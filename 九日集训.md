### c九日集训

#### 第一日：

##### 输出两个数中较大的一个 不可以用if-else判断语句

```c
int maximum(int a, int b
{
    return (a>b) ? a : b;
    // 考察的是唯一的三目运算符
    // 表达式1？表达式2:表达式3
    // conditional operator ?
    // variable = Expression1 ? Expression2 : Expression3;
    // (condition) ? (variable = Expression2) : (variable = Expression3);
    // if condition is true variable = Expression2
    // else variable = Expression3
    
    if (Expression1)
        variable = Expression2;
    else
        variable = Expression3;
```

##### 判断一个数翻转两次是不是还是原来的数字：

```c
/*
反转 一个整数意味着倒置它的所有位。

例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。
给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。
*/

class Solution {
public:
    // 数字翻转
    int reverseNum(int num)
    {
        int reversedNum = 0;
        while(num != 0 )
        {
            int digit = num % 10;
            reversedNum = 10* reversedNum + digit;
            num = int(num / 10);
        }
        return reversedNum;    
    }

    bool isSameAfterReversals(int num) {
        // 翻转两次 判断是不是原来的数字
        int reversedNUM = reverseNum(num);
        int rereversedNUM = reverseNum(reversedNUM);
        return num == rereversedNUM;
    }
};

// 分析：除了0以外，只要最后一位不是0两次翻转肯定是原来的数
// 当num == 0 或 最后一位不是0
    bool isSameAfterReversals(int num) {
        return num == 0 || num % 10!= 0 ? true : false;
        
    }

```



### 第二日：

```c
for (initializationStatement; testExpression; updateStatement)
{   //    循环初始化表达式;		  循环条件表达式; 	 循环执行表达式
    // statements inside the body of loop
}

初始化表达式外置:
    int i = 1;                  // (2)
    int sum = 0;                // (3)
    for(; i <= n; ++i) {        // (4)
        sum += i;               // (5)
    }

初始化表达式内置:
    int i, sum;                           
    for(i = 1, sum = 0; i <= n; ++i) {    // (4)
        sum += i;                         // (5)
    }

省略条件表达式:(没有循环条件/没有循环结束判断语句，意味着这是一个死循环)
    int i;                 // (2)
    int sum = 0;           // (3)
    for(i = 1;; ++i) {     // (4)
        sum += i;          // (5)
    }

执行表达式:(让循环条件的判断逐渐变得不成立，从而跳出循环，也可以内置到循环主体内)
    int i, sum = 0;           // (2)
    for(i = 1; i <= n;) {     // (3)
        sum += i;             // (4)
        ++i;
    }

```

##### 判断是否为3的幂的表达式：

```c
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n == 1)
            return true;
        
        for (int i = 1; pow(3,i)<= pow(2,31); i++ ){
            if (n == pow(3,i))
            {
                return true;
            }}
        return false;
            
    }
};
```

##### 判断是否为完全平方数：

```c
bool isPerfectSquare(int num) {
    if (sqrt(num) == (int)(sqrt(num)))
        return true;
    else
        return false;
}



#include <math.h>
bool isPerfectSquare(int num) {
    for (int i = 0; i <= (int)((sqrt(num))+1); i++) {
        if ((double)i * i == num) {
            return true;
        }
    }
    return false;
}
// i是整型int 所以i*i会继承i的整型类型 这样有可能会导致i*i溢出 
// 两种解决方法
// 1. 将i直接定义成长整型long这样就会防止溢出
// 2. 将乘法之后的结果转变为长整型



#include <math.h>
bool isPerfectSquare(int num) {
    for (double i = 0; (double) i * i <= num; i++) {
        if (i * i == num) {
            return true;
        }
    }
    return false;
}
```



#### 第三天：

数组的定义以及初始化

```c
int a[7];

int a[7] = {5, 2, 0, 1, 3, 1, 4};

int a[] = {5, 2, 0, 1, 3, 1, 4};

int a[19] =  {5, 2, 0, 1, 3, 1, 4};

/*
在定义数组的时候和引用数组索引的时候是不一样的
int a[7] 指的是创建一个包含七个元素的数组
但是数组的元素的索引从0开始，七个元素所以索引为0-6，也就是说索引是a[0]到a[6]
*/

int a[7] = {5, 2, 0, 1, 3, 1, 4};
int b = a[0];  // 5
int c = a[6];  // 4
int d = a[7];  // error


// 利用传入参数，来实现数组中所有元素的累加
int add(int nums[10], int numsSize) {
    int i;
    int s = 0;
    for(i = 0; i < numsSize; ++i) {
    	s += nums[i];
    }
    return s;
}

// int nums[] 与 int *nums 等效 *代表指针
```

##### 查找数组中是否包含指定元素

```c
// 当数组长度没有给定 需要手动获取数组长度
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 获取数组长度
        int size = nums.size();
        // 索引的最后一位是size-1，因为索引从0开始
        // 所以循环结束的条件是 i = size-1
        for (int i = 0; i<= size-1; i++){
            if (target == nums[i])
                return i;
        }
        return -1;
    }
};

// 当数组长度给定了 可以直接获取
int search(int* nums, int numsSize, int target){  // (1)
    for(int i=0; i<numSize; i++){
        if (nums[i] == target)
            return i;
    }
    return -1;
};

// 返回target是否在数组中 使用return true/false 都可以
```

##### 爬楼梯：(本质是斐波那契数列)

```c
class Solution {
public:
    int climbStairs(int n) {
        int Steps[100];
        Steps[0] = 1;
        Steps[1] = 1;

        for(int i = 2; i<= n; i++){
            // 关于为什么本质是斐波那契数列
            // 到达n级台阶一共有两种可能性
            // 在n-1级台阶再走一级台阶
            // 在n-2级台阶再走两级台阶
            // 为什么在n-2台阶的时候只有一种可能性 不是可以走两级台阶/走两次一级台阶吗
            // 因为在n-2的时候走一级台阶就转变为了 n-1级台阶再走一级
            // 所以走到n级台阶等于 走到n-1级的可能性 + 走到n-2级的可能性
            Steps[i] = Steps[i-1] + Steps[i-2];
        }
        return Steps[n];
    }
};
```

##### 拿硬币：

```c
// 代码不难 奇数偶数分情况讨论
class Solution {
public:
    int minCount(vector<int>& coins) {
        int CoinSize = coins.size();
        int cnt = 0;
		
        // 真实分析奇偶数情况
        /*
        for(int i = 0; i< CoinSize; i++){
            int is_odd = coins[i] % 2;
            switch(is_odd){
                case 0:
                    cnt += (coins[i]/2);
                    break;
                case 1:
                    cnt += (coins[i]/2) + 1;
                    break;
            }
        }
        return cnt;
        */
		
        // 奇数+1/2 会+1
        // 偶数+1/2 不会+1
        for(int i = 0; i< CoinSize; i++){
            cnt += (coins[i]+1)/2;
        }
        return cnt;
    }
};
```

##### 山峰数组：

```c
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int SizeOfArr = arr.size();



        /*
        for (int i = 1; i < SizeOfArr - 1; i++) {
            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
                peak = i;
                break;1、指针即地址

            }
        }
        */

        int left = 1;
        int right = arr.size() - 2;
        // 山峰不可嫩出现在数组的首尾
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 如果中间的数处在递增区间内 mid左侧都为递增
            // 更改左边查找范围
            // 山峰在mid右侧
            if (arr[mid] < arr[mid + 1]) {
                left = mid + 1;
            } else {
                // 中间的数处在递减区间内 mid右侧为递减
                // 要更改右边查找范围
                // 山峰在mid左侧
                right = mid;
            }
        }
        
        return left;
    }
};
```

#### 第四天：指针

##### 指针即地址：

  计算机中所有的数据都必须放置在内存中，不同类型的数据占用的字节数也不一样，例如 32位整型`int`占据 4 个字节，64位整型`long long`占据 8 个字节，字符型`char`占据 1 个字节。
  为了能够正确地访问这些数据，必须为每个字节都编上编号，每个字节的编号是唯一的。
  我们把内存中字节的编号称为 **地址** 或 **指针**。地址从 0 开始依次递增，对于 32 位环境下，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。

##### 指针的定义：

在C语言中，可以用一个变量来存放指针，这种变量称为指针变量。指针变量的值，通俗来说就是某一个变量的地址。
  现在假设有一个`char·`类型的变量`x`，它存储了字符`'o'`，并占用了地址为`0xCF`的内存（地址通常用十六进制表示）。另外有一个指针变量`p`，它的值为`0xCF`，正好等于变量`x`的地址，这种情况我们就称`p`指向了`x`，或者说`p`是指向变量`x`的指针。
![img](https://img-blog.csdnimg.cn/7ba595ba38094c9cbe258e2dce5839ac.png#pic_center)
  其中 *p* 是指针变量名，*x* 是被指向的变量的变量名；`0xCF`是 指针变量 *p* 的值，也是 *x* 的地址；`'o'`是 *x* 的值。

##### 定义指针变量：

定义指针变量和普通变量类似，只不过在变量名前面加上一个星号`*`即可。C语言实现如下：

```c
DataType *dataName;
```

  我们用到最多的指针变量类型为整型，可以这么写：

```c
int *p;
```

  对于字符类型的指针变量，可以这么写：

```c
char *p;
```

##### 取地址：

我们回到上面的问题，假设 �*x* 是一个字符型变量，�*p* 是 �*x* 的地址，那么伪代码应该是这样的：

```c
char x = 'o';
char *p = (x)的地址;
```

  而实际写代码的时候，我们通过`&`来表示取地址符号，也就是代码可以写成：

```c
char x = 'o';
// 常见的固定的范式
// 初始化了一个指针p,并将其指向a的地址
// 不代表 *p存储的是x的地址
char *p = &x;
```

##### 数组的地址：

对于数组而言，其中的元素的地址都是连续的，数组第一个元素的地址可以用数组名来表示，实现如下：

```c
int a[] = {5,2,0,1,3,1,4};
int *p = a;
```

  简而言之，`p`指向数组第一个元素的地址，`a`也是数组第一个元素的地址。

##### 解引用：

 解引用是取地址的逆操作，即根据给定的地址，获取它的值。用`*`运算符来实现，如下：

```c
int a;
int *p = &a;
a == *p;

void main(){
    int a = 10; // 创建一个整型变量a,并将其初始化为a
    int *b = &a; // 创建一个指向整数的指针b,并将其指向整数a的地址
    // b是一个指针，存储的是a的地址; b是一个指向a的指针,b存储了a的地址
    // *b是通过指针b获取的内容; *b得到的是b所指向的地址的值,也就是变量a的值
    printf("num is %d \n", *b);
    printf("address is %p", b);
}

```

  一句话解释，`p`代表`a`的地址，`*p`代表`a`的值；

##### 内存申请：

C语言中，利用函数`malloc`来申请内存，传入参数为申请内存的字节数，返回值为申请到的内存的首地址，是什么类型的地址，就要强转成什么类型，如下：

```c
	int *p = (int *)malloc(1024);
	// 使用malloc()函数创建一个长度为传入参数长度的内存地址 返回的是申请到的内存首地址 并将这个内存地址强制转换为整型
	// 创建一个指针p 并指向返回的内存首地址
    // 这个指针指向的是一个整型的内存地址 所以定义一个指向整型的指针
    // malloc可能会在内部分配稍微多一点的内存
	// 在使用完这些内存后需要用 free(p)来释放这些内存
```

  `p`代表的是申请到的内存，并且有效内存字节数为 1024。
  如果我们要申请一个长度为 *n* 的整型数组的内存，可以这么写：

```c
	int *p = (int *)malloc( sizeof(int) * n );
	// 使用单个整型的内存size ＊n表示长度为n的整型
```

  其中`sizeof(int)`表示的是一个`int`占用的字节数，那么一个长度为*n* 的`int`类型的数组，需要的字节数自然就是 `sizeof(int) * n`。

##### 返回数组：

 一般在刷题的时候，要求返回一个数组，这就比较尴尬，尴尬在哪里呢？
  因为函数只能有一个返回值，而数组除了需要知道数组的首地址，还需要知道数组元素的个数。
  所以，LeetCode 的做法是，通过函数的参数传递一个指针变量进来，然后让调用者去填充这个指针变量，如下：

```c
int *getList(int *nums, int numsSize, int *returnSize) {
    // ...
    // 为什么需要两个数组元素的个数 numsSize和returnSize都代表了数组的元素个数
    // 是因为数组长度和实际的数组中元素个数有可能不同
    /*
    int a[10] = {1,2,3,4,5,6,7,8};  // numSize = 10;
    int rSize;    // rSize = 8
    int *ret = getList(a, 10, &rSize); 
    // 返回数组不光需要数组首地址，还需要数组元素的个数
    // 返回的数组元素首地址就是数组的名称，元素长度有两种表达
    // 第一种是 numsSize数组元素长度*(定义时候的长度) 10
	// 第二种是 rSize数组中元素个数(实际长度) 8
	// 调用 getList(a, 10, &rSize) 时，虽然传递了 10 作为 numsSize，但函数内部可能会根据实际数组中		   的元素来计算 rSize，以保证返回的数组长度是正确的。
       所以，使用 numsSize 和 rSize 两个变量允许在函数内部计算实际的数组长度，并在返回时将正确的长度          通过指针返回给调用方。这在处理数组长度不固定的情况下非常有用。
    */
    
    // returnSize 是一个指向 rSize 的指针。
	// *returnSize 解引用这个指针，得到的是 rSize 的值。
	// 通过修改 *returnSize，你修改了 rSize 的值。
}
```

  这里的`returnSize`是一个指针，它指向的就是一个代表数组长度的变量，它是没有赋值的，需要我们通过解引用对它进行赋值。
  函数的调用方，其实是这么调用的：

```c
    int a[7] = {5, 2, 0, 1, 3, 1, 4};
    int rSize;
    int *ret = getList(a, 7, &rSize);
```

  这里的`&rSize`含义就是取了`rSize`的地址，传递给`returnSize`时，自然就成了指针。这样，在函数内部对`*returnSize`进行修改，自然就改了`rSize`的值，调用函数的一方自然就知道这个数组的长度了。

##### 范式：

所谓范式，就是规范写法的意思。就是按照这种规范写法写，能解决大部分问题。有关返回一维数组的问题，我们有通用范式，如下：

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().  // (1)
 */
 int *func(int *nums, int numsSize, int *returnSize) {                     // (2)
     int *ret = (int *)malloc( sizeof(int) * xxx );                        // (3)
     // TODO                                                               // (4)
     *returnSize = xxx;                                                    // (5)
     return ret;                                                           // (6)
 }
```

- (1)(1) 这一句话一般是系统提示你，需要申请内存，并且返回申请内存的首地址；
- (2)(2) 这里会有两个返回值，一个是数组首地址（体现在返回值上），一个是数组大小（体现在指针传参上）；
- (3)(3) 利用`malloc`申请一块自定义大小的内存；
- (4)(4) 做你要做的事情；
- (5)(5) 利用解引用，将需要返回的数组的长度告诉调用者；
- (6)(6) 返回申请的数组内存的数组首地址；

##### 概念总结：

| 名词       | 简介         |
| ---------- | ------------ |
| 指针       | 变量的地址   |
| 取地址     | 变量 -> 地址 |
| 解引用     | 地址 -> 变量 |
| 数组首地址 | 用数组名表示 |
| 范式       | 规范写法     |

/////////////////////////在此之前代码都是cpp的 记得修改

##### 重新排列数组：

```c
// 注意范式!!!
// 可以按照范式复制

/**
 * Note: The returned array must be malloced, assume caller calls free().
 // 这句话是核心，返回的数组必须是通过malloc进行内存分配的，因为调用者会对它进行free的清理操作
 // 数组的真实长度为2n
 // x_1, x_2, ..., x_n 为第0个到第 n-1个元素
 // y_1, y_2, ..., y_n 为第n个到第2n-1个元素

 */
int* shuffle(int* nums, int numsSize, int n, int* returnSize){
    // 这个函数的返回值是int *，即返回的是一个数组的首地址，但是数组的大小也需要让调用者知道，所以通过一个传参returnSize来传递出去   
    
    int* ret = (int *)malloc( sizeof(int) * numsSize);
	// 申请一个长度为numsSize的数组，首地址为ret
    
    
	// 排列x 从0开始每隔两个放入一个x
    for(int i = 0; i< numsSize; i+=2){
        // 根据题目要求，将nums的数据填充到ret中
        ret[i] = nums[(i/2)];
    }
        
    // 排列y 从1开始每隔两个放入一个y
    for(int j = 1; j< numsSize; j+=2){
        ret[j] = nums[j/2+n];
    }
    
    * returnSize = numsSize;
	// 最后，别忘了利用解引用，将需要返回的数组的长度告诉调用者；

    return ret;
    // 返回你申请的数组的首地址；

}
```

##### 左旋字符串

```c
// 两种解题思路
// 第一种将两个字符串拼接在一起,然后从起始位置开始抽取
char* reverseLeftWords(char* s, int n){
    int charlength = strlen(s);
    char* ret = (char *)malloc(sizeof(char)* 2 *charlength);
    for(int i = 0; i< charlength; i++){
        ret[i] = s[i];
        ret[i+charlength] = s[i];
    }

    for(int j = 0; j< charlength;j++){
        s[j] = ret[n+j];
    }

    return s;    
}

// 第二种开辟一个相同长度的数组,按照需求开始抽取
// 需要注意的是字符串是以null终止的字符数组，这就意味着字符串的末尾必须有一个特殊字符'\0'来表示字符串的结束。这个字符告诉程序在哪里字符串结束，因此程序可以正确地处理字符串。
// 在C语言中，如果用标准的字符串函数库（如strcpy、strcat、sprintf等），它们会自动在新字符串的末尾添加'\0'字符，以确保字符串的正确终止。因此，如果使用这些函数来构建新的字符串，无需手动添加'\0'字符。
// 如果手动分配内存，并逐字符来构建新的字符串，就需要确保在字符串的末尾手动添加"\0"字符

char* reverseLeftWords(char* s, int n){
    int len = strlen(s);
    char* result = malloc(sizeof(char) * len + 1);
    // 原先的字符串已经藏了一个"\0", 所以字符串的实际长度比我们获取的长度长1
    // 字符串的终止字符"\0"是不计入字符串长度的
    
    // 用count来定位新字符串的位置
    int count = 0;
    // 用i来定位”指针“扫过原来字符串s的位置
    // 从左旋位置起始处开始向右扫
    for (int i = n; i < len; i++) {
        result[count++] = s[i];
    }
    // 从位置0开始向右扫到左旋位置
    for (int i = 0; i < n; i++) {
        result[count++] = s[i];
    }
    // 为新创建的数组末尾添加一个终止符
    result[count] = '\0';
    return result;
}

```

##### ip地址无效化

```c
char * defangIPaddr(char * address){
    int len_ip = strlen(address);
    // 每个dot添加一对括号，一共有三个点
    // 为最后一位预留一位null的位置,记住最后一位的索引是new_len_ip - 1
    int new_len_ip = len_ip + 2*3 + 1;
    // count是新数组的光标
    int count = 0;

    char* new_address = (char *)malloc( sizeof(char) * new_len_ip);
    for(int i = 0; i < len_ip; i++){
        // 发现不是点，就原封复制数字
        if(address[i] != '.'){
            new_address[count++] = address[i];
        }
        else{
            // 如果是点就替换
            new_address[count] = '[';
            new_address[count + 1] = '.';
            new_address[count + 2] = ']';
            count += 3;
        }
    }
    new_address[new_len_ip-1] = '\0';
    return new_address;

}

// 下一题还需要先行循环 计算空格个数
```

##### 有多少小于与当前数字的数字

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){

    // 创建一个新数组用于统计 该数组包含101个元素 对应101个数字

    int Array[101];
    for(int i = 0 ; i<101; i++ ){
        Array[i] = 0;
    }

    for(int j = 0; j < numsSize; j++){
        // nums[j]是nums中的每个元素分别是几
        // 将统计数组中的该元素个数+1
        Array[nums[j]]++;
    }

    // 创建一个新的用于返回的数组
    int * new_nums = (int *) malloc( sizeof(int) * numsSize);
    // k是扫原来nums中的指针 元素位置一一对应 并且用nums[k]来获取该元素内容
    for(int k = 0 ; k< numsSize; k++){
        // 计数器计算在此之前的元素有多少个
        int count = 0;
        for(int m = 0; m < nums[k]; m++){
            count += Array[m];
        }
        new_nums[k] = count;
    }

    * returnSize = numsSize;
    return new_nums;
}
```

####  

#### 第五天：排序

```c
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*));

```

##### qsort简介

| 参数   | 说明                                                     |
| ------ | -------------------------------------------------------- |
| base   | 指向要排序的数组的第一个元素的指针                       |
| nitems | 由base指向的数组中元素的个数                             |
| size   | 数组中的每个元素的大小，以字节为单位                     |
| compar | 用来比较两个元素的函数，即函数指针（比较算法的回调函数） |

##### qsort调用

```c
int a[5] = {4, 5, 3, 2, 1};

qsort(a, 5, sizeof(int), cmp);

{1, 2, 3, 4, 5};

// sizeof(int)就代表了单个数组元素的字节数
// 5则代表了数组的大小，总的字节数就是两者的乘积 
// cmp是一个比较函数，是需要我们自己实现的，它决定了数组是递增排序 还是 递减排序，还是其它的排序方式（比如奇数排前面，偶数排后面，等等
```

##### 比较函数cmp：

1) 函数原型

   ```c
   int compar(const void *p1, const void *p2);
   ```

   如果`compar`返回值小于0，则`p1`所指向元素会被排在`p2`所指向元素的左面；
   如果`compar`返回值等于0，则`p1`所指向元素与`p2`所指向元素的顺序不确定；
   如果`compar`返回值大于0，则`p1`所指向元素会被排在`p2`所指向元素的右面。

   

2) 函数定义

   ​		如果，我们要写一个递增排序，那么可以这么写：

   ```c
   int cmp(const void*p1, const void *p2) { // (1)
       int v1 = *(int *)p1;                 // (2)
       int v2 = *(int *)p2;                 // (3)
       if(v1 < v2) {                        // (4)    
           return -1;
       }else if(v1 > v2) {
           return 1;
       }
       return 0;
   }
   // (1) 需要和系统给定的函数原型保持一致，由于需要适配任何类型，所以用空指针void *做为参数类型；
   // (2) p1强制转换成数组元素的指针类型，然后再解引用 变成数组元素的值；
   // (3) p2强制转换成数组元素的指针类型，然后再解引用 变成数组元素的值；
   // (4) 根据上面的规则进行实际的函数返回，有关解引用相关的内容可以参考： 《LeetCode零基础指南》(第四讲) 指针。
   
   
   
   
   int cmp(const void* a, const void* b) {
       int intA = *((int*)a);
       int intB = *((int*)b);
   
       if (intA < intB) return -1;
       if (intA > intB) return 1;
       return 0;
   }
   // 如果 a 应该排在 b 前面，比较函数返回负整数（通常是负1）。
   // 如果 a 应该排在 b 后面，比较函数返回正整数（通常是正1）。
   // 如果 a 和 b 相等，比较函数返回0。
   ```

3) 简化写法

     当然，如果你确保数组的数据相减不会超过32位整型，那你可以这么写：

   ```c
   int cmp(const void *p1, const void *p2) {
       return (*(int *)p1) - (*(int *)p2);
   }
   ```

4) 更多比较函数

     当然，我们也可以实现递减的比较函数，如下（可以直接交换`p1`和`p2`的位置即可，自行思考）：

   ```c
   int cmp(const void *p1, const void *p2) {
       return (*(int *)p2) - (*(int *)p1);
   }
   ```

​		  如果要求偶数排前面，奇数排后面，可以这么写：

```c
    int Qua(int x) {
        return x % 2;
    }

// Qua 一共有两种输出结果 0/1
// 偶数在前意思是0在前 1在后
// p1=0 p2=1 不需要对换 p1在前 返回负数  负数为0-1
// p1=1 p2=0 需要对换   p1在后 返回正数  正数为1-0
// 所以两种情况均为p1-p2
    int cmp(const void *p1, const void *p2) {
        return Qua(*(int *)p1) - Qua(*(int *)p2);
    }
```

##### 时间比较

```c
// 递增排序
int cmp( const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

int min (int x_1, int x_2){
    return x_1 < x_2 ? x_1 : x_2;
}

int findMinDifference(char ** timePoints, int timePointsSize){
    // 最大时间差为1440分钟 = 24h
    int differ = 1440;
    int a, b ;
    // 创建一个新的数组 包含的是每一个时间对于00:00的分钟差
    int *ret = (int *)malloc( sizeof(int) * timePointsSize);
	
    // 利用格式化输入输出 获取小时和分钟来计算与00:00的分钟差
    for(int i = 0; i< timePointsSize; i++){
        sscanf(timePoints[i],"%d:%d", &a, &b);
        // a：b = 60 * a 分钟 + b 分钟
        ret[i] = 60 * a + b ;
    }
	
    // 按照时间差排序 也就是说按照时间从早到晚排序
    qsort(ret, timePointsSize, sizeof(int), cmp);
    // 对已经排序的数组的相邻两个时间做时间差，后面的时间减前面的时间得到就是>0的时间差
    // 取所有时间差最小值
    for(int j = 0; j < timePointsSize -1; j++){
        differ = min(differ, (ret[j+1] - ret[j]));
    }
	
    // 虽然已经两两比较了，但是第一个和最后一个时间还没有比较
    // 但是本质其实是第二天的最早时间 与 第一天的最晚时间比较
    // === 第一天的最早时间+24h 与 第一天的最晚时间比较
    differ = min(differ, 1440 + ret[0] - ret[timePointsSize-1]);
    return differ;
}
```

##### 三角形的三边最大之和

```c
// 递增排序
int cmp(const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

// 对于一条大边，如果他以下最大的两条边都不能构成三角形 那么剩下的所有小边都不能构成三角形
int largestPerimeter(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    for(int i = numsSize -1 ; i >=  2; i--){
        if(nums[i-2] + nums[i-1] > nums[i]){
            return nums[i-2] + nums[i-1] + nums[i];
        }
    }
    return 0;
}  
```

##### 救生艇问题：

```c
int cmp( const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

int numRescueBoats(int* people, int peopleSize, int limit){
    int count_boat = 0;
    qsort(people, peopleSize, sizeof(int), cmp);
    // 单循环 三种情况
    for(int i = 0; i < peopleSize; i++){
        // 情况2，3 最重的人可能可以带上别人(他的体重不等于限重) 
        if(people[peopleSize-1] < limit){
            // 情况2: 最重的人不可以搭上最轻的人，与情况1相同
            // 船数+1，最重的人离开，最轻的人还是最轻的人
            if(people[peopleSize-1] + people[i] > limit){
                count_boat ++;
                peopleSize --;
                i --;
            }
            // 情况3: 最重的人可以搭上最轻的人
            // 最重的人和最轻的人都离开
            else{
                count_boat ++;
                peopleSize --;
            }
        }
        // 情况1：他不能和别人拼坐，他的体重等于限重，必须一个人坐一辆船
        else{
            // 船数+1，最重的人离开，最轻的人还是最轻的人
            // 由于循环会默认+1使得最轻的人变成下一个人 所以需要手动-1变回当前最轻的人
            count_boat ++;
            peopleSize --;
            i --;
        } 
    }
    return count_boat;

}
```



#### 第六天：贪心算法

##### 摆动排序：

```c
int cmp( const void * p1, const void * p2){
    return (* (int *)p2) - (* (int *)p1);
}

void wiggleSort(int* nums, int numsSize){
    int * ret = (int * )malloc( sizeof(int) * numsSize);
    qsort(nums, numsSize, sizeof(int), cmp);
    for(int i = 0; i < (numsSize)/2; i++){
        ret[2*i+1] = nums[i]; 
    }

    int count = 0;
    for(int j = (numsSize)/2; j < numsSize; j++){
        ret[count] = nums[j];
        count += 2;
    }
    for(int k = 0; k < numsSize; k++){
        nums[k] = ret[k];
    }
}

// 写得很烂 标答如下:
int cmp(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

void wiggleSort(int* nums, int numsSize){
    int i;
    int l, r;
    int *ret = (int *)malloc( sizeof(int) * numsSize );
    // 将 nums里面的所有元素复制出来到ret
    for(i = 0; i < numsSize; ++i) {
        ret[i] = nums[i];                     
    }
    // 对ret进行递增排序
    qsort(ret, numsSize, sizeof(int), cmp);  
    // 末尾位置(最大元素)
    r = numsSize-1;
    
    // 偶数位置上 
    for(i = 1; i < numsSize; i += 2) {
        nums[i] = ret[r--];                   // (3)
    }
    // 奇数位置上
    for(i = 0; i < numsSize; i += 2) {
        nums[i] = ret[r--];                   // (4)
    }    
}
```

##### 分饼干：

```c
int cmp( const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

int min( int x_1, int x_2){
    return x_1 < x_2 ? x_1 : x_2;
}

int findContentChildren(int* g, int gSize, int* s, int sSize){
    // 对胃口和饼干进行递增排序
    qsort(g, gSize, sizeof(int), cmp);
    qsort(s, sSize, sizeof(int), cmp);
    // 一共可以满足多少个小孩
    int count = 0;
    // 找到可以可以满足最小胃口的小孩的最小的饼干的索引
    int least = 0;
    for(int j = 0; j < sSize; j++){
        if(s[j] >= g[0]){
            least = j;
            break;
        }
    }

    // 如果当前饼干可以满足当前小孩的胃口
    // i(小孩+1)， least(饼干+1)
    for(int i = 0; i < min(gSize, sSize); i++){
        if(g[i] <= s[least]){
            count ++;
            // 注意不能超过饼干索引的上下限
            if((least+1)< sSize)
                least++;
            else
                break;
        }
        // 如果当前饼干不可以满足当前小孩的胃口
        // i(小孩不变需要-1) least(饼干+1)
        // 尝试用下一个饼干满足小孩的胃口
        else{
            i--;
            if((least+1)< sSize)
                least++;
            else
                break;
        }
    }
    return count;
} 2 3 4 4
```

##### 有效三角形的个数

```c
int cmp(const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

int triangleNumber(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int cnt = 0;
    // 三循环 时间复杂度过高 会超时
    for(int i = numsSize-1; i>=2; i--){
        for(int j = i-1; j>=1; j--){
            for(int k = j-1; k>=0; k--){
                if(nums[j]+nums[k]> nums[i]){
                    cnt++;
                }       
                else
                    break;
            }
        }   
    }
    return cnt;
}
```

##### 

```c
int cmp(const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

int triangleNumber(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int cnt = 0;
    int k;
    for(int i = numsSize-1; i>=2; i--){
        for(int j = i-1; j>=1 && nums[j] != 0; j--){
            k = j - 1;
            while(k >= 0 && nums[j]+nums[k]> nums[i]){
                    k--;
                }   
             cnt += j-k-1;    
            }
        }   
    return cnt;
}
```

##### 

```c
int cmp(const void * p1, const void * p2){
    return (* (int *)p1) - (* (int *)p2);
}

int triangleNumber(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    // 初始化计数器
    int cnt = 0;
    // 三角形判断公式 
    // 三角形三边分别为a,b,c 且满足a<b<c
    // 那么a+b>c
    // i === c 最大边
    for(int i = numsSize-1; i>=2; i--){
        // left === a 最小边
        int left = 0;
        // right === b 次大(小)边
        int right = i-1;
        
        while(left < right){
            // 当前配置能满足三角形判断条件
            // 次大边带任意一个最小边都可以满足组成三角形的条件 则在其中间的的都可以作为最小边
            if (nums[left] + nums[right] > nums[i]){
                cnt += right - left;
                // 更换次大边为更小一条 再次尝试
                right--;
            }
            else
                // 次大边带上当前最小边不足以满足三角形条件，则增大最小边 直至不满足循环判断条件
                left++;
        }

    }   
    return cnt;
}
```



#### 第七天：二维数组

#### 1、矩阵的定义

矩阵 A<sub>*n×m*</sub> 的定义是按照长方阵列排列的复数或实数集合，其中 *n* 代表行数， *m* 代表列数。如下所示，代表的是一个 4×3 的矩阵
$$
A_{4×3} = \left[
 \begin{matrix}
   0 & 1 & 0 \\
   0 & 0 & 1 \\
   1 & 0 & 0 \\
   1 & 0 & 0
  \end{matrix}
  \right]
$$

  在C语言中，我们可以用`A[n][m]`来代表一个 *n*×*m* 的矩阵，其中`A[i][j]`代表矩阵第 *i* 行，第 *j* 列的值。

#### 矩阵的水平翻转

 矩阵的水平翻转，就是将矩阵的每一行的元素进行逆序，矩阵 A<sub>*4×3*</sub> 水平翻转后的结果如下所示：
$$
A'_{4×3} = \left[
 \begin{matrix}
   0 & 1 & 0 \\
   1 & 0 & 0 \\
   0 & 0 & 1 \\
   0 & 0 & 1
  \end{matrix}
  \right]
$$

#### 矩阵的垂直翻转

矩阵的垂直翻转，就是将矩阵的每一列的元素进行逆序，矩阵 A<sub>*4×3*</sub>水垂直翻转后的结果如下所示：
$$
A''_{4×3} = \left[
 \begin{matrix}
   1 & 0 & 0 \\
   1 & 0 & 0 \\
   0 & 0 & 1 \\
   0 & 1 & 0
  \end{matrix}
  \right]
$$

#### 矩阵的顺时针旋转

矩阵的顺时针旋转 90 度，顾名思义，就是绕着垂直屏幕向里的方向，对矩阵进行 90度旋转，这时候行列会交换，所以矩阵  A<sub>*4×3*</sub> 顺时针90度旋转后的结果如下所示：
$$
A'''_{3×4} = \left[
 \begin{matrix}
   1 & 1 & 0 & 0 \\
   0 & 0 & 0 & 1 \\
   0 & 0 & 1 & 0 
  \end{matrix}
  \right]
$$

#### 矩阵的逆时针旋转

矩阵的逆时针旋转 90 度，我们可以理解成 顺时针旋转 270 度，所以就是做 3 次顺时针旋转 90 度的操作。

#### 矩阵的转置

矩阵的转置，就是对矩阵的主对角线对称的元素进行交换的操作，矩阵  A<sub>*4×3*</sub>  转置的结果如下：
$$
A^T_{3×4} = \left[
 \begin{matrix}
   0 & 0 & 1 & 1 \\
   1 & 0 & 0 & 0 \\
   0 & 1 & 0 & 0 
  \end{matrix}
  \right]
$$

#### 二维数组

  C语言中，二维数组可以用来描述矩阵，定义如下（3 行 4 列）：

```C
int a[3][4];
```

​		我们也可以将二维数组的元素进行初始化，如下：

```c
int a[3][4] = {
	{5, 2, 0, 4}
	{1, 3, 1, 7}
	{4, 0, 0, 9}
};
```

  由于编译器能够通过后面的初始化列表知道到底有多少个数据元素，所以第一个中括号中的数字可以省略（但是第二个不能省略），如下：

```c
int a[][4] = {
	{5, 2, 0, 4}
	{1, 3, 1, 7}
	{4, 0, 0, 9}
};
```

  当然，我们还可以定义一个大数组，但是只初始化其中几行元素：

```c
int a[100][4] = {
	{5, 2, 0, 4}
	{1, 3, 1, 7}
	{4, 0, 0, 9}
};
```

  本质上，你可以把二维数组理解成一个一维数组。只不过一维数组的每一个元素，也是一个一维数组。

#### 二维数组的索引

C语言中数组下标从 0 开始，那么，如果要取得数组`a`的*i* 行 *j* 列的元素，可以通过`a[i][j]`进行获取。

#### 二维数组的函数传参

如果你已经了解了一维数组的传参，那么大概应该能猜出二维数组的传参。
  我们来回顾一下一维数组的传参，用的是一个`*`，如下：

```c
int add(int *nums, int numsSize) {
    // ...
}
```

  那么二维数组的传参，用的就是两个`*`了，如下：

```c
int diagonalSum(int** mat, int matSize, int* matColSize){
}
```

  其中`matSize`代表**二维数组第一维的大小，也就是可以理解成有多少行**；`int* matColSize`是**一个一维数组，代表每一行有多少列**，即`matColSize[0]`代表第 0 行有`matColSize[0]`列，`matColSize[1]`代表第 1 行有`matColSize[1]`列，`matColSize[i]`代表第 *i* 行有`matColSize[i]`列，以此类推。
  由于矩阵的每一列元素都是一样的，所以这类题目中，我们一般可以初始化怎么写：

```c
int diagonalSum(int** mat, int matSize, int* matColSize){
    r = matSize; // ROW
    // matColSize[i]代表的是第i行有多少列
    // 由于矩阵的每一行的元素个数相同 而且(一定存在)第0行的元素个数就是多少列
    c = matColSize[0]; // COLUMN
    // TODO
}
```

  这样写的好处是把变量命名简单化，后续使用的时候不容易出错，让代码更加易读。

##### 矩阵对角线元素的和

```c
int diagonalSum(int** mat, int matSize, int* matColSize){
    int rows = matSize;
    int cols = matColSize[0];
    int sum = 0;

    // main diag
    for(int i = 0; i < rows; i++){
        sum += mat[i][i];
    }
	
    // 水平翻转 再取主对角线
    for (int i = 0; i < rows; i++) {
        int left = 0;
        int right = cols - 1;
        
        while (left < right) {
            // 交换元素
            int temp = mat[i][left];
            mat[i][left] = mat[i][right];
            mat[i][right] = temp;
            
            left++;
            right--;
        }
    }

    for(int i = 0; i < rows; i++){
        sum += mat[i][i];
    }

    if(rows % 2 == 1){
        sum -= mat[(rows)/2][(rows)/2];
    }
    return sum;
}



int diagonalSum(int** mat, int matSize, int* matColSize){
    int rows = matSize;
    int cols = matColSize[0];
    int sum = 0;

    int i = 0;          // [i][i] 是左上角 --> i++为主对角线
    int j = rows - 1;   // [i][j] 是左下角 --> i++ j-- 为副对角线
    // 分别从左上角和左下角逐步覆盖对角线

    while(i < rows){
        // 从左上角左下角能迫近到同一个元素 证明为奇数阵 中间元素只计算一次
        if(i == j){
            sum += mat[i][i];
        }
        else{
            sum += mat[i][i] + mat[i][j];
        }
        i++;
        j--;
    }
    return sum;
}
```

##### 托普利茨矩阵

```c
bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){
    int rows = matrixSize;
    int cols = matrixColSize[0];
    // 排除第0行与第0列的所有元素
    for(int i = 1; i < rows; i++ ){
        for(int j = 1; j < cols; j++){
            // 检查该元素是否与其左上角的元素相等
            if( matrix[i][j] != matrix[i-1][j-1])
                return false;
        }
    }
    return true;
}



bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){
    int rows = matrixSize;
    int cols = matrixColSize[0];

    int curr_Array[cols];
    int temp_Array[cols];
    // 复制第一行
    for(int k = 0 ; k< cols; k++){
        curr_Array[k] = matrix[0][k];
    }

    for(int i = 1; i < rows; i++ ){
        for(int n = 0 ; n< cols; n++){    
            temp_Array[n] = curr_Array[n];
        }
        for(int j = 0; j < cols; j++ ){
            curr_Array[j] =  matrix[i][j];
        }
        for(int m = 0; m< cols-1; m++){
            if(temp_Array[m] != curr_Array[m+1])
                return false;
        }
    }
    return true;
}
```



##### 岛屿的周长

```c
int MIN(int x_1, int x_2){
    return x_1 < x_2 ? x_1 : x_2;
}


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    int rows = matrixSize;
    int cols = matrixColSize[0];
    int cnt = 0;

    int * ret = (int *)malloc( sizeof(int) * MIN(rows, cols));

    for(int i = 0; i < rows; i++){
        int min_pos = 0;
        for(int j = 1; j < cols ; j++){
            if(matrix[i][min_pos] > matrix[i][j]){
                min_pos = j;
            }
        }
        
        int max_pos = 0;
        for(int k = 1; k < rows; k++){
            if(matrix[max_pos][min_pos] < matrix[k][min_pos]){
                max_pos = k;
            }
        }
        if(i == max_pos){
            ret[cnt++] = matrix[i][min_pos];
        }
    }


    * returnSize = cnt;
    return ret;

}


[0,0,0,0,0,1,0,0]
[0,0,0,0,1,0,0,1]
[0,0,0,0,1,0,0,0]
[1,0,0,0,1,0,0,0]
[0,0,1,1,0,0,0,0]]
    
    
    
    
    int numSpecial(int** mat, int matSize, int* matColSize) {
    int rows = matSize;
    int cols = matColSize[0];
    int cnt = 0;

    for(int i = 0; i < rows; i++){
        for(int j = 0; j < cols; j++){
            if(mat[i][j] == 1){
                int rows_sum = 0;
                int cols_sum = 0;
                for(int m = 0; m < cols; m++){
                    rows_sum += mat[i][m];
                }

                for(int n = 0; n < rows; n++){
                    cols_sum += mat[n][j];
                }

                if(rows_sum == 1 && cols_sum == 1){
                    cnt++;
                }
            }
        }
    }
    
    return cnt;
}


int islandPerimeter(int** grid, int gridSize, int* gridColSize){
    int rows = gridSize;
    int cols = gridColSize[0];
    int cnt = 0;
    int jump_rows = 0;
    int jump_cols = 0;
	
    // 横向交界
    for(int i = 0; i < rows; i++){
        for(int j = 0; j < cols-1 ; j++){
            if(grid[i][j] != grid[i][j+1])
                jump_rows++; 
        }
    }
	
    // 纵向交界
    for(int j = 0; j < cols; j++){
        for(int i = 0; i < rows -1 ; i++){
            if(grid[i][j] != grid[i+1][j])
                jump_cols++;
        }
    }
    
    // 计算外圈的边
    // 第0行与最后一行
    // 第0列到第cols-1列
    for(int n = 0; n < cols; n++){
        if(grid[0][n] == 1){
            cnt ++;
        }

        if(grid[rows-1][n] == 1){
            cnt ++;
        }
    }

    // 第0列或者第最后一列
    // 从第0行到rows-1列
    for(int n = 0; n < rows; n++){
        if (grid[n][0] == 1){
            cnt++;
        }

        if (grid[n][cols - 1] == 1){
            cnt++;
        }
    }
	
    return cnt+jump_cols+jump_rows;
}
```



### 第八天：二级指针

指针变量也是一种变量，也会占用存储空间，也可以使用`&`获取它的地址。
  如果一个指针指向另外一个指针，我们就称它为二级指针，或者指向指针的指针。用C语言描述如下：

```c
int x = 1;
int *p1 = &x;
int **p2 = &p1;
```

  当然，还有三级指针，四级指针，几乎很少用到，这里不再累述。大概是这幅样子：

```c
int ***p3 = &p2;
int ****p4 = &p3;
```

## 解引用

  在学习一级指针的时候，我们用过`*`进行解引用。一级指针经过一次解引用，变成普通变量。二级指针经过一次解引用，变成一级指针。

```c
int *p1 = *p2;
```



#### Recap：力扣中的一级指针

```c
// 注意范式!!!
// 可以按照范式复制

/**
 * Note: The returned array must be malloced, assume caller calls free().
 // 这句话是核心，返回的数组必须是通过malloc进行内存分配的，因为调用者会对它进行free的清理操作
 // 数组的真实长度为2n
 // x_1, x_2, ..., x_n 为第0个到第 n-1个元素
 // y_1, y_2, ..., y_n 为第n个到第2n-1个元素

 */
int* shuffle(int* nums, int numsSize, int n, int* returnSize){
    // 这个函数的返回值是int *，即返回的是一个数组的首地址，但是数组的大小也需要让调用者知道，所以通过一个传参returnSize来传递出去   
    
    int* ret = (int *)malloc( sizeof(int) * numsSize);
	// 申请一个长度为numsSize的数组，首地址为ret
    
    
	// 排列x 从0开始每隔两个放入一个x
    for(int i = 0; i< numsSize; i+=2){
        // 根据题目要求，将nums的数据填充到ret中
        ret[i] = nums[(i/2)];
    }
        
    // 排列y 从1开始每隔两个放入一个y
    for(int j = 1; j< numsSize; j+=2){
        ret[j] = nums[j/2+n];
    }
    
    * returnSize = numsSize;
	// 最后，别忘了利用解引用，将需要返回的数组的长度告诉调用者；

    return ret;
    // 返回你申请的数组的首地址；

}
```



## 力扣中的二级指针

  在 LeetCode 中，选择 C语言 进行求解时，往往出现如下的情况，这是什么意思呢？

```c
int** func(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
}
```

| 参数名              | 变量类型 | 实际含义                                                     |
| ------------------- | -------- | ------------------------------------------------------------ |
| `matrix`            | 二级指针 | 传入的矩阵首地址                                             |
| `matrixSize`        | 普通变量 | 传入的矩阵的行数                                             |
| `matrixColSize`     | 一级指针 | 传入矩阵每行的列数（注意是每行，所以是数组）                 |
| `returnSize`        | 一级指针 | 传出矩阵的行数，由于需要作为参数返回，所以用指针取地址       |
| `returnColumnSizes` | 二级指针 | 传出矩阵的每行的列数，由于需要作为数组参数返回，所以用二级指针 |

对于`returnColumnSizes`这个参数，补充几点：
  1）它是一个 指向数组 的 指针，这里数组是行数组；
  2）`*returnColumnSizes`是实际的那个数组，并且数组的每个元素是 `(*returnColumnSizes)[i]`代表的是列数；
  3）`return`是个前缀，代表它的定位是 **返回值**，而不是 **函数传参**；

## 4、内存申请模板

  所谓模板，就是写完以后，每个题目都能套着用，今天我们就来提炼一个有关于二维数组的内存申请的模板。大致声明如下：

```c
int **myMalloc(int r, int c, int* returnSize, int** returnColumnSizes);
```

  其中，返回值代表申请的二维数组（为了方便理解，我们叫矩阵吧）的首地址。`r`和`c`代表矩阵的行和列，`returnSize`是需要返回给调用方的，实际的矩阵的行，我们会在函数内部将它赋值为`r`，而`returnColumnSizes`也是需要返回给调用方的，只不过需要返回的是一个数组。所以需要用二级指针（思考：为什么返回数组要用二级指针）。
  这个函数就可以作为我们的模板函数的，我们接下来来实现一下它：

```c
// 为什么需要这个myMalloc函数？
// 因为返回一维数组与返回二维数组不同
// 一维数组可以直接创建一个数组，并返回数组的首项与指针
// 创建二维数组与此不同，需要创建两个。所以写成函数形式更加简单

// 创建一个二位数组的固定模板
// 返回值必定是创建的矩阵(二位数组)
// 除此以外也要将 *returnSize 与 *returnColumnSizes也定义
int **myMalloc(int r, int c, int* returnSize, int** returnColumnSizes) {
    // 首先创建一个二维数组(数组的长度为r，代表有r行；数组中的每一个元素都是一个一维指针)
    // **ret = {*a,*b,*c} 这就是一个r=3的数组 数组的每一个都是指针吗
    // 每一个指针再指向一个一维数组，这就构成了一个二位数组；
    int **ret = (int **)malloc( sizeof(int *) * r );        // (1)
    // returnColumnSizes是一个存储了每一行个数的数组 所以returnColumnSize的长度等于行数
    // e.g. returnColumnSizes = {3, 3, 3}
    // 就是一个三行三列的矩阵
    // 两次解引用
    // 第一次解引用是将returnColumnSizes指针指向的内存地址值取出来
    // returnColumnSizes指向的是存储每行有多少个元素的数组
    *returnColumnSizes = (int *)malloc( sizeof(int) * r );  // (2)
    // 第二次解引用是将returnSize指针指向的值取出来
    // returnSize指向的是ret的行数的数组
    *returnSize = r;                                        // (3)
    // 现在有了存储指针的n行数组
    // 再加上存储每行有多少元素的数组
    for(int i = 0; i < r; ++i) {
        // ret[i] 是指创建的n行数组中的第i行 指向的时候returnColumnSizes[i]
        // 这样就可以获取第i行有多少个列元素
        // 现在刚好是反过来的 我知道的是每行有多少个元素 
        // 所以我将数组的第i个指针(第i行) 都分配c个列元素
        ret[i] = (int *)malloc( sizeof(int) * c );			// (4)
        // 要返回列长度 为c
        (*returnColumnSizes)[i] = c;                        // (5)
    }    
    // 将二维数组返回
    return ret;
}
```

- (1)(1) 申请一个矩阵（二维数组）的内存，行数为 `r`，首地址为`ret`，二维数组的类型为`int **`，二维数组中每个元素的类型为一级指针，即`int *`，对应`sizeof(int *)`这个表达式；
- (2)(2) 为这个矩阵的列申请一个数组来记录它每一行的列数，所以这个列数组的长度应该是行数`r`，由于需要作为参数返回给调用方，所以这里调用了一次解引用；
- (3)(3) `*returnSize`是需要返回的矩阵的行数，调用者不知道这个功能返回的矩阵有多少行，需要实现者告诉他，同样调用一次解引用；
- (4)(4) 申请矩阵每一行的内存空间，每一行的长度为`c`，即列数；
- (5)(5) 每一行的列数长度需要作为返回值返回，所以需要先解引用再索引到行号，即给`(*returnColumnSizes)`进行赋值；

##### 翻转图像

```c
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int ** ret = (int **)malloc(sizeof( int *) * r);
    *returnSize = r;
    * returnColumnSizes = (int *)malloc(sizeof(int) * r);

    for(int i= 0; i < r; i++){
        ret[i] = (int *)malloc(sizeof(int) * c);
        (*returnColumnSizes)[i] = c;
    }

    return ret;
}

// 实现翻转
int Reverse(int x){
    return x == 0? 1:0;
}
// 答案是用 1 - ans实现翻转的
//  0 --  1-0  ==> 1
//  1 --  1-1  ===> 0
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){
    int rows = imageSize;
    int cols = imageColSize[0];
    int **ret = (int **)myMalloc(rows, cols, returnSize, returnColumnSizes);
    // 创建一个临时变量 用于两两更换
    int temp ;
    for(int i = 0; i< rows; i++){
        for(int j = 0 ; j < cols; j++){
            temp = image[i][cols-1-j];
            ret[i][cols-1-j] = Reverse(image[i][j]);
            ret[i][j] = Reverse(temp);
        }c
    }
    return ret;

}
```

##### 转置矩阵

```c
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int i;
    int ** ret =(int **)malloc(sizeof(int * ) * r);
    * returnSize = r;
    * returnColumnSizes = (int *)malloc(sizeof(int) * r);
    for(i = 0; i < r; i++){
        ret[i] = (int *)malloc(sizeof(int) * c);
        (* returnColumnSizes)[i] = c;
    }
    return ret;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
    int rows = matrixSize;
    int cols = matrixColSize[0];
	
    // 转置后行列转换
    // 所以新矩阵的列数为原来的行数 新矩阵的行数为原来的列数
    int ** ret = (int **)myMalloc(cols, rows, returnSize, returnColumnSizes);
    // 所以现在是j行 i列
    for(int i = 0; i < cols; i++){
        for(int j = 0; j < rows; j++){
            ret[i][j] = matrix[j][i];
        }
    }
    return ret;
}

```

##### 重塑矩阵：

```c
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int ** ret = (int **)malloc( sizeof(int *) * r);
    * returnSize = r;
    * returnColumnSizes = (int *)malloc( sizeof(int) * r);

    for(int i = 0; i < r; i++){
        ret[i] = (int *)malloc(sizeof(int) * c);
        (* returnColumnSizes)[i] = c;
    }    
    return ret;
}
/**  
* Return an array of arrays of size *returnSize.  
* The sizes of the arrays are returned as *returnColumnSizes array.  
* Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().  
*/
int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){
    int old_rows = matSize;
    int new_rows = r;

    int old_cols = matColSize[0];
    int new_cols = c;

    // 需要变化或者不需要变化
    // 需要变化的话就需要开辟新尺寸的数组内存用于存放重新排列的元素
    // 返回的时候记得返回新的尺寸
    if(old_cols*old_rows == new_cols* new_rows){
        // 用于记录原来位置的座标
        int cnt_rows = 0;
        int cnt_cols = 0;

        int ** ret = (int **)myMalloc(new_rows, new_cols, returnSize, returnColumnSizes);
        // i j 控制新矩阵的座标  
        for(int i = 0; i < new_rows; i++){
            for(int j = 0; j < new_cols; j++){
                ret[i][j] = mat[cnt_rows][cnt_cols];
                cnt_cols++;
				
                // 当原来的光标超过列原来矩阵的尺寸 指列数超过了
                // 移动到下一行的第0列元素
                if (cnt_cols == old_cols) {
                    cnt_rows++;
                    cnt_cols = 0;
                } 
            }
        }
        return ret;
    } else {        
        // 不需要变化的话直接将原来的矩阵返回
        // 返回的时候记得返回正确的尺寸
        *returnSize = matSize;
        *returnColumnSizes = matColSize;
        return mat;
        }

}
```

##### 将一维数组转变为二维数组

```c
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int i;
    int ** ret = (int **)malloc(sizeof(int *) *r);
    * returnColumnSizes =(int *)malloc(sizeof(int ) * r);
    * returnSize = r;

    for(int i = 0; i< r; i++){
        ret[i] = (int *)malloc(sizeof(int) * c);
        (* returnColumnSizes)[i] = c;
        
    }
    return ret;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){
    int old_rows = 1;
    int old_cols = originalSize;

    int new_rows = m;
    int new_cols = n;
	
    int cnt = 0;
    
    int ** ret = (int **)myMalloc(new_rows, new_cols, returnSize, returnColumnSizes);

	// 整体逻辑与前一道题相同 只是空的二位数组的返回问题
    if(new_cols* new_rows != originalSize){ 
        // 二维数组的转换为空数组就是 一个行数为0的空数组
        *returnSize = 0;
        return ret;
    } else {        
        for(int i = 0; i < new_rows; i++){
            for(int j = 0; j < new_cols; j++){
                ret[i][j] = original[cnt];
                cnt ++;
            }
        }
        return ret;
    }  
}
```

##### 二维网络迁移

```c
 int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int i;
    int ** ret = (int **)malloc(sizeof(int *) *r);
    * returnColumnSizes =(int *)malloc(sizeof(int ) * r);
    * returnSize = r;

    for(int i = 0; i< r; i++){
        ret[i] = (int *)malloc(sizeof(int) * c);
        (* returnColumnSizes)[i] = c;
        
    }
    return ret;
}
/** 
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int rows = gridSize;
    int cols = gridColSize[0];
    
    int Array[2 * rows * cols] ;
    int cnt = 0;
    for(int i = 0; i < rows; i++){
        for(int j = 0; j < cols ; j++){
            Array[cnt] = grid[i][j];
            Array[cnt + rows * cols] = grid[i][j];
            cnt++;
        }
    }

    int ** ret = (int **)myMalloc(rows, cols, returnSize, returnColumnSizes);
    cnt = rows * cols - k;
    // e.g. 一个元素循环100次的话会让cnt失效
    while(cnt < 0){
        cnt += rows * cols;
    }
    for(int i = 0; i < rows; i++){
        for(int j = 0; j < cols ; j++){
            ret[i][j] = Array[cnt++];
        }
    }

    return ret;
}
```

##### 图片平滑器

```c
 
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int ** ret = (int **)malloc( sizeof(int *) * r);
    * returnSize = r;
    * returnColumnSizes = (int *)malloc( sizeof(int) * r);


    for(int i = 0; i < r; i++){
        ret[i] = (int *)malloc(sizeof(int)* c);
        (* returnColumnSizes)[i] = c;
    }
    return ret;
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){
    int rows = imgSize;
    int cols = imgColSize[0];
    int sum, cnt;
	
    // 非常经典的一个对于最外层边框的判断
    // 矩阵内部函数进行一个操作，对最外层边框进行另一种操作
    int ** ret = (int **)myMalloc(rows, cols, returnSize, returnColumnSizes);
    for(int i = 0; i < rows ; i++){
        for(int j = 0; j < cols; j++){
            sum = 0;
            cnt = 0;
            for(int m = i-1; m < i+2; m++){
                for(int n = j-1; n< j+2; n++){
                    if(m>=0 && m<rows && n>=0 && n<cols){
                        sum += img[m][n];
                        cnt ++;
                    }
                }
            }
            ret[i][j] = sum/cnt;
        }
    }
    return ret;


}
```

##### 距离顺序排列矩阵单元格

```c
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    int ** ret = (int **)malloc(sizeof(int *) * r);
    * returnSize = r;
    * returnColumnSizes = (int *)malloc( sizeof(int) * r);

    for(int i = 0; i < r; i++){
        ret[i] = (int *)malloc( sizeof(int) * c);
        (* returnColumnSizes)[i] = c;
    }
    
    return ret;
}


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes){
    int k = 0;

    int r = rows;
    int c = cols;
    int rC = rCenter;
    int cC = cCenter;
    int ** ret = (int **)myMalloc(r * c, 2, returnSize, returnColumnSizes);
    

int rC, cC;

int cmp(const void * p1, const void * p2){
    int row_p1 = (*(int**)p1)[0];
    int col_p1 = (*(int**)p1)[1];

    int row_p2 = (*(int**)p2)[0];
    int col_p2 = (*(int**)p2)[1];

    int distance_p1 = abs(row_p1 - rC ) + abs(col_p1 - cC);
    int distance_p2 = abs(row_p2 - rC) + abs(col_p2 - cC);

    return distance_p1 - distance_p2;    
}

    for(int i = 0; i < r; i++){
        for(int j = 0; j < c; j++){
            ret[k][0] = i;
            ret[k][1] = j;
            k++;
        }
    }

    qsort(ret, r*c, sizeof(int*),cmp);
    return ret;


}

// 由于cmp函数的特殊性,导致其不能接受传入参数，但是cmp函数不得不调用rCenter与cCenter两个参数
// 所以有两种解决方案
// 第一种是将rCenter和cCenter两个变量定义成全局变量
// 第二种是将cmp函数写在主程序内部，这样就可以直接调用主程序传入的两个参数


```



#### 第九天：简单递归

##### 递归的含义：

递归就是函数自己调自己。

>   递归只要记住三点内容：
>   1）你要实现一个函数，这个函数会自己调用自己，并且每次调用，函数传参是不一样的；
>   2）递归一定要有出口，即满足一定条件后需要`return`，否则就可能出现 **死递归**（引起栈溢出）；
>   3）根据递推式来补充你的递归调用内容；

```c
int trailingZeroes(int n){
    if(n < 5) {
        return 0;                         // (1)
    }
    return n / 5 + trailingZeroes(n/5);   // (2)
}
```

- (1)(1) 当 *n*<5 的时候，由于 *n*! 中没有 10 这个因子，尾部自然是没有零的；
- (2)(2) 于是，我们发现，问题本质就是求 1010 的因子的数量， 而在*n*! 中，2 的因子不会少于 5。所以其实试求 5 的因子数量。

  求 5 的因子数量，我们可以把所有 5 的倍数（且非 25 的倍数）找出来，有 *n/5* 个；所有 25 的倍数（且非 125 的倍数）找出来，*n/25* 个；所有 125 的倍数找出来，*n/125* 个；以此类推，所以，我们令*f*(*n*) 表示 *n* 的 5 因子数，它就等于：
$$
f(n) = \frac{n}{5} + \frac{n}{25} + \frac{n}{125} + ...
$$

  再将它转换成递推式，得到：
$$
f(n) = \frac{n}{5} + f(\frac{n}{5}) 
$$
然后就可以用递推式来套用递归求解了。

##### 将数字变为0的操作次数

```c
int numberOfSteps(int num){
    if(num != 0){
        if(num % 2 == 0)
            return numberOfSteps(num/2) + 1;
        else   
            return numberOfSteps(num-1) + 1;
    }
    else
        return 0;
}
```



## ***3、完全二叉树的节点个数

>   给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 ℎ*h* 层，则该层包含 1−2ℎ1−2*h* 个节点。

```c
int countNodes(struct TreeNode* root){
    if(root == NULL) {
        return 0;             // (1) 
    }                         // (2) 
    return countNodes(root->left) + countNodes(root->right) + 1;
}
```

- (1)(1) 空树的结点数为 0；
- (2)(2) 非空树的结点数为 左子树个数 + 右子树个数 + 1；

##### 写一个简单的二分树

```c
#include<stdio.h>
#include<stdlib.h>

typedef struct node{
    int data;
    struct node* left;
    struct node* right;
} Node;

// 先序遍历指的是对于一个节点 先打印根节点，再访问左节点，再访问右节点
void Preorder(Node* node){
    if (node != NULL){
        printf("%d\n",node->data);
        Preorder(node->left);
        Preorder(node -> right);
    }
}

// 中序遍历 先访问左节点 再访问根结点 再访问右节点
void Inorder(Node* node){
    if (node != NULL){
        Inorder(node->left);
        printf("%d", node->data);
        Inorder(node->right);
    }
}

// 后序遍历 先访问左节点 再访问右节点 再访问根节点
void postorder(Node* node){
    if (node != NULL){
        postorder(node -> left);
        postorder(node -> right);
        printf("%d", node -> data);
    }
}


int main(){
    Node n1;
    Node n2;
    Node n3;
    Node n4;
	
    // 定义节点
    n1.data = 5;
    n2.data = 6;
    n3.data = 7;
    n4.data = 8;

    n1.left  = &n2;
    n1.right = &n3;
    n2.left  = &n4;
    n2.right = NULL;
    n3.left  = NULL;
    n3.right = NULL;

    Preorder(&n1);
    printf("--------------\n");
    Inorder( &n1);
    printf("--------------\n");
    Postorder(&n1);
}

```



```c
// 创建一个深度搜索的树 判断哈希表中的相对应的元素改为1
// max节点个数为1000
// 所以需要创建1001个哈希表 因为可以存储1-1000或者null-999

// 实现类似一个普通数组

void DFS(struct TreeNode* root, int *hash, int *count){
    if(root == NULL){
        return;
   }
    if(hash[root->val] == 0){
        *count += 1;
        hash[root->val] = 1;
    }
    DFS(root->left, hash, count);
    DFS(root->right, hash, count);
}

int numColor(struct TreeNode* root){
    int hash[1001] = {0};
    int count = 0;
    DFS(root, hash, &count);
    // 传入的时候给的是变量count的地址 以便可以修改外部变量
    return count;
}
```


